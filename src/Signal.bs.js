// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function make(initial) {
  return {
          value: {
            contents: initial
          },
          subscriptions: {
            contents: /* [] */0
          }
        };
}

function get(signal) {
  return signal.value.contents;
}

function set(value, signal) {
  signal.value.contents = value;
  List.map((function (sub) {
          return Curry._1(sub, value);
        }), signal.subscriptions.contents);
  return /* () */0;
}

function subscribe(sub, signal) {
  signal.subscriptions.contents = /* :: */[
    sub,
    signal.subscriptions.contents
  ];
  return Curry._1(sub, signal.value.contents);
}

var Signal = {
  make: make,
  get: get,
  set: set,
  subscribe: subscribe
};

function run(signal) {
  return subscribe((function (value) {
                return Curry._1(value, /* () */0);
              }), signal);
}

function unwrap(signal) {
  var run = signal.value.contents;
  var out = make(Curry._1(run, /* () */0));
  var update = function (value) {
    return set(Curry._1(value, /* () */0), out);
  };
  return subscribe(update, signal);
}

function every(interval) {
  var out = make(Date.now());
  setInterval((function (param) {
          return set(Date.now(), out);
        }), interval);
  return out;
}

function map(func, signal) {
  var out = make(Curry._1(func, signal.value.contents));
  var produce = function (value) {
    return set(Curry._1(func, value), out);
  };
  subscribe(produce, signal);
  return out;
}

function flatMap(func, signal) {
  return Curry._1(func, signal.value.contents);
}

function apply(source, signal) {
  var func = source.value.contents;
  var out = make(Curry._1(func, signal.value.contents));
  var produce = function (_value) {
    return set(Curry._1(func, signal.value.contents), out);
  };
  subscribe(produce, source);
  subscribe(produce, signal);
  return out;
}

function merge(source, signal) {
  var out = make(signal.value.contents);
  var produce = function (value) {
    return set(value, out);
  };
  subscribe(produce, source);
  subscribe(produce, signal);
  return out;
}

function foldp(func, seed, signal) {
  var acc = {
    contents: seed
  };
  var out = make(acc.contents);
  var produce = function (value) {
    acc.contents = Curry._2(func, value, acc.contents);
    return set(acc.contents, out);
  };
  subscribe(produce, signal);
  return out;
}

function sampleOn(source, signal) {
  var out = make(source.value.contents);
  var produce = function (_value) {
    return set(source.value.contents, out);
  };
  subscribe(produce, signal);
  return out;
}

function dropRepeats(signal) {
  var prev = {
    contents: signal.value.contents
  };
  var out = make(prev.contents);
  var produce = function (next) {
    if (prev.contents !== next) {
      prev.contents = next;
      return set(prev.contents, out);
    } else {
      return 0;
    }
  };
  subscribe(produce, signal);
  return out;
}

function filter(func, a, signal) {
  var value = signal.value.contents;
  var match = Curry._1(func, value);
  var out = make(match ? value : a);
  var produce = function (value) {
    if (Curry._1(func, value)) {
      return set(value, out);
    } else {
      return 0;
    }
  };
  subscribe(produce, signal);
  return out;
}

function flatten(b, signal) {
  var seed = b;
  var value = signal.value.contents;
  if (!Array.isArray(value)) {
    Js_exn.raiseError("Cannot flatten a value that is not an array");
  }
  var first = {
    contents: value.slice()
  };
  if (first.contents.length > 0) {
    seed = Caml_array.caml_array_get(first.contents, 0);
  } else {
    first.contents = /* array */[];
  }
  var out = make(seed);
  var feed = function (items) {
    items.forEach((function (item) {
            return set(item, out);
          }));
    return /* () */0;
  };
  var produce = function (value) {
    if (first.contents === /* array */[]) {
      return feed(value);
    } else {
      feed(first.contents.slice(1));
      first.contents = /* array */[];
      return /* () */0;
    }
  };
  setTimeout((function (param) {
          return subscribe(produce, signal);
        }), 0);
  return out;
}

function on(func, signal) {
  var produce = Curry.__1(func);
  subscribe(produce, signal);
  return signal;
}

function delay(time, signal) {
  var out = make(signal.value.contents);
  var first = {
    contents: true
  };
  var produce = function (value) {
    if (first.contents) {
      first.contents = false;
      return /* () */0;
    } else {
      setTimeout((function (param) {
              return set(value, out);
            }), time);
      return /* () */0;
    }
  };
  subscribe(produce, signal);
  return out;
}

function since(time, signal) {
  var out_value = {
    contents: false
  };
  var out_subscriptions = {
    contents: /* [] */0
  };
  var out = {
    value: out_value,
    subscriptions: out_subscriptions
  };
  var first = {
    contents: true
  };
  var timer = {
    contents: undefined
  };
  var tick = function (param) {
    set(false, out);
    timer.contents = undefined;
    return /* () */0;
  };
  var produce = function (_value) {
    var match = first.contents;
    if (match) {
      first.contents = false;
      return /* () */0;
    } else {
      var match$1 = timer.contents;
      if (match$1 !== undefined) {
        clearTimeout(Caml_option.valFromOption(match$1));
      } else {
        set(true, out);
      }
      timer.contents = Caml_option.some(setTimeout(tick, time));
      return /* () */0;
    }
  };
  subscribe(produce, signal);
  return out;
}

var constant = make;

exports.Signal = Signal;
exports.constant = constant;
exports.run = run;
exports.unwrap = unwrap;
exports.every = every;
exports.map = map;
exports.flatMap = flatMap;
exports.apply = apply;
exports.merge = merge;
exports.foldp = foldp;
exports.sampleOn = sampleOn;
exports.dropRepeats = dropRepeats;
exports.filter = filter;
exports.flatten = flatten;
exports.on = on;
exports.delay = delay;
exports.since = since;
/* No side effect */
